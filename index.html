<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pixelate - pixel art creator</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="alternate icon" type="image/svg+xml" href="favicon.svg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #fffbeb;
            color: #78350f;
            line-height: 1.6;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulance type='fractalNoise' baseFrequency='0.9' numOctaves='4' /%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100' height='100' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E");
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 2rem 2rem 1rem 2rem;
        }

        h1 {
            font-size: 4rem;
            font-weight: 900;
            text-transform: lowercase;
            color: #78350f;
            margin-bottom: 0.75rem;
            text-align: center;
        }

        .subtitle {
            font-size: 1.25rem;
            font-weight: 700;
            text-transform: lowercase;
            color: #92400e;
            text-align: center;
            margin-bottom: 3rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 2.5rem;
            margin-bottom: 2rem;
            align-items: start;
        }

        .controls-panel {
            background: white;
            padding: 2rem;
            border: 2px solid #78350f;
            box-shadow: 6px 6px 0px rgba(120, 53, 15, 0.15);
            display: flex;
            flex-direction: column;
            gap: 1.75rem;
            height: fit-content;
            position: sticky;
            top: 2rem;
        }

        .control-section {
            padding-bottom: 1.75rem;
            border-bottom: 2px solid #fef3c7;
        }

        .control-section:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .control-section h3 {
            font-size: 1.1rem;
            font-weight: 900;
            text-transform: lowercase;
            color: #1d4ed8;
            margin-bottom: 1rem;
        }

        .color-picker-group {
            margin-bottom: 0.75rem;
        }

        .color-picker-group:last-child {
            margin-bottom: 0;
        }

        .color-picker-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 700;
            text-transform: lowercase;
            color: #78350f;
            margin-bottom: 0.5rem;
        }

        .color-picker {
            width: 100%;
            height: 50px;
            border: 2px solid #78350f;
            border-radius: 4px;
            cursor: pointer;
        }


        .btn {
            width: 100%;
            padding: 0.875rem;
            font-weight: 700;
            text-transform: lowercase;
            border: 2px solid #78350f;
            background: #2563eb;
            color: white;
            cursor: pointer;
            margin-bottom: 0.625rem;
            font-size: 0.875rem;
            transition: all 0.3s;
            box-shadow: 3px 3px 0px rgba(120, 53, 15, 0.15);
        }

        .btn:last-child {
            margin-bottom: 0;
        }

        .btn:hover:not(:disabled) {
            background: #1d4ed8;
            transform: translateY(-2px);
            box-shadow: 4px 4px 0px rgba(120, 53, 15, 0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: white;
            color: #78350f;
        }

        .btn-secondary:hover {
            background: #fff4ca;
            color: #78350f;
        }

        .btn.reset-btn:hover {
            background: #fff4ca;
            color: #78350f;
        }

        .btn-surprise {
            background: linear-gradient(135deg, #5C81F6 0%, #9B87F5 100%);
            border: 2px solid #78350f;
            font-size: 1rem;
            margin-bottom: 0;
        }

        .btn-surprise:hover {
            background: linear-gradient(135deg, #4A6FD4 0%, #8975D3 100%) !important;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 4px 4px 0px rgba(120, 53, 15, 0.2);
        }

        .grid-size-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.625rem;
            margin-bottom: 0.75rem;
        }

        .grid-size-btn {
            padding: 0.625rem;
            font-weight: 700;
            text-transform: lowercase;
            border: 2px solid #78350f;
            background: white;
            color: #78350f;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
            box-shadow: 2px 2px 0px rgba(120, 53, 15, 0.15);
        }

        .grid-size-btn.active {
            background: #2563eb;
            color: white;
        }

        .grid-size-btn:hover {
            transform: translateY(-1px);
            box-shadow: 3px 3px 0px rgba(120, 53, 15, 0.2);
        }

        .tool-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.625rem;
            margin-bottom: 0.75rem;
        }

        .tool-btn {
            padding: 0.75rem;
            font-weight: 700;
            text-transform: lowercase;
            border: 2px solid #78350f;
            background: white;
            color: #78350f;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
            box-shadow: 2px 2px 0px rgba(120, 53, 15, 0.15);
        }

        .tool-btn.active {
            background: #2563eb;
            color: white;
        }

        .tool-btn:hover {
            transform: translateY(-1px);
            box-shadow: 3px 3px 0px rgba(120, 53, 15, 0.2);
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 3rem;
            border: 2px solid #78350f;
            box-shadow: 6px 6px 0px rgba(120, 53, 15, 0.15);
            background: white;
            width: 100%;
            min-height: 650px;
        }

        #pixelCanvas {
            border: 2px solid #78350f;
            cursor: crosshair;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        footer {
            background: white;
            border-top: 2px solid #78350f;
            padding: 2rem;
            text-align: center;
            width: 100%;
            margin-top: 2rem;
        }

        .contact-links {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .contact-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem 2rem;
            font-weight: 700;
            text-transform: lowercase;
            text-decoration: none;
            border: 2px solid #78350f;
            transition: all 0.3s;
            box-shadow: 4px 4px 0px rgba(120, 53, 15, 0.2);
        }

        .contact-btn:hover {
            transform: translateY(-2px);
            box-shadow: 6px 6px 0px rgba(120, 53, 15, 0.25);
        }

        .contact-btn.email {
            background: #2563eb;
            color: white;
        }

        .contact-btn.portfolio {
            background: #78350f;
            color: white;
        }

        .contact-btn.linkedin {
            background: #fef3c7;
            color: #78350f;
        }

        footer p {
            color: #92400e;
            font-size: 0.875rem;
            font-weight: 700;
            text-transform: lowercase;
            margin: 0.25rem 0;
        }

        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 280px 1fr;
                gap: 1.5rem;
            }

            .controls-panel {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 2.5rem;
                margin-bottom: 0.5rem;
            }
            
            .subtitle {
                font-size: 1rem;
                margin-bottom: 2rem;
            }

            .main-layout {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .controls-panel {
                padding: 1.5rem;
                gap: 1.25rem;
                position: static;
            }

            .control-section {
                padding-bottom: 1.25rem;
            }

            .canvas-container {
                padding: 1.5rem;
                min-height: 400px;
            }

            .contact-links {
                flex-direction: column;
                align-items: stretch;
                gap: 1rem;
            }

            .contact-btn {
                width: 100%;
                justify-content: center;
            }

            footer {
                padding: 1.5rem 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>pixelate</h1>
        <p class="subtitle">▪ create pixel art one square at a time ▪</p>
        
        <div class="main-layout">
            <div class="controls-panel">
                <div class="control-section">
                    <h3>grid size</h3>
                    <div class="grid-size-selector">
                        <button class="grid-size-btn" onclick="setGridSize(16)">16x16</button>
                        <button class="grid-size-btn active" onclick="setGridSize(32)">32x32</button>
                        <button class="grid-size-btn" onclick="setGridSize(64)">64x64</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>tools</h3>
                    <div class="tool-selector">
                        <button class="tool-btn active" onclick="setTool('draw')">✏ draw</button>
                        <button class="tool-btn" onclick="setTool('erase')">⌫ erase</button>
                        <button class="tool-btn" onclick="setTool('fill')">⬓ fill</button>
                        <button class="tool-btn" onclick="setTool('pick')">⊙ pick</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>current color</h3>
                    <div class="color-picker-group">
                        <input type="color" id="currentColor" class="color-picker" value="#2563eb">
                    </div>
                </div>

                <div class="control-section">
                    <h3>templates</h3>
                    <button class="btn btn-surprise" onclick="generateRandomArt()">✨ surprise me!</button>
                </div>

                <div class="control-section">
                    <h3>actions</h3>
                    <button class="btn btn-secondary reset-btn" onclick="clearCanvas()">clear canvas</button>
                    <button class="btn btn-secondary reset-btn" onclick="fillBackground()">fill background</button>
                </div>

                <div class="control-section">
                    <h3>save</h3>
                    <button class="btn btn-secondary reset-btn" onclick="downloadPixelArt()">download (large)</button>
                    <button class="btn btn-secondary reset-btn" onclick="downloadPixelArtSmall()">download (small)</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="pixelCanvas"></canvas>
            </div>
        </div>
    </div>

    <footer>
        <div class="contact-links">
            <a href="mailto:ns2229@cornell.edu" class="contact-btn email">
                <span>✉</span>
                <span>email</span>
            </a>
            <a href="https://naishasrivastava.github.io/" target="_blank" class="contact-btn portfolio">
                <span>★</span>
                <span>portfolio</span>
            </a>
            <a href="https://www.linkedin.com/in/naishasrivastava" target="_blank" class="contact-btn linkedin">
                <span>in</span>
                <span>linkedin</span>
            </a>
        </div>
        <p>made with ♥ by naisha srivastava</p>
        <p>© 2026</p>
    </footer>

    <script>
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        
        let gridSize = 32;
        let pixelSize = 16;
        let currentColor = '#2563eb';
        let currentTool = 'draw';
        let isDrawing = false;
        let grid = [];
        let currentPatternIndex = 0;

        // const defaultPalette = [
        //     '#2563eb', '#1d4ed8', '#78350f', '#92400e',
        //     '#fef3c7', '#fde68a', '#ffffff', '#000000',
        //     '#ef4444', '#f97316', '#22c55e', '#06b6d4',
        //     '#8b5cf6', '#ec4899', '#a3e635', '#fb923c'
        // ];


        function init() {
            setupCanvas();
            setupEventListeners();
            clearCanvas();
        }

        function setupCanvas() {
            // Calculate optimal canvas size based on viewport
            const containerWidth = document.querySelector('.canvas-container').clientWidth;
            const maxCanvasSize = Math.min(containerWidth - 100, 650);
            pixelSize = Math.floor(maxCanvasSize / gridSize);
            const size = gridSize * pixelSize;
            
            canvas.width = size;
            canvas.height = size;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            
            // Initialize grid
            grid = Array(gridSize).fill().map(() => 
                Array(gridSize).fill('transparent')
            );
        }


        function setupEventListeners() {
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);
            canvas.addEventListener('click', handleClick);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                canvas.dispatchEvent(mouseEvent);
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                canvas.dispatchEvent(mouseEvent);
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup', {});
                canvas.dispatchEvent(mouseEvent);
            });
            
            document.getElementById('currentColor').addEventListener('input', (e) => {
                currentColor = e.target.value;
                document.querySelectorAll('.palette-color').forEach(el => {
                    el.classList.remove('active');
                });
            });
        }

        function getPixelPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor(((e.clientX - rect.left) * scaleX) / pixelSize);
            const y = Math.floor(((e.clientY - rect.top) * scaleY) / pixelSize);
            return { x, y };
        }

        function startDrawing(e) {
            if (currentTool === 'fill' || currentTool === 'pick') return;
            isDrawing = true;
            draw(e);
        }

        function draw(e) {
            if (!isDrawing) return;
            if (currentTool !== 'draw' && currentTool !== 'erase') return;
            
            const { x, y } = getPixelPosition(e);
            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                if (currentTool === 'draw') {
                    grid[y][x] = currentColor;
                } else if (currentTool === 'erase') {
                    grid[y][x] = 'transparent';
                }
                renderGrid();
            }
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function handleClick(e) {
            const { x, y } = getPixelPosition(e);
            
            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;
            
            if (currentTool === 'fill') {
                floodFill(x, y, grid[y][x], currentColor);
                renderGrid();
            } else if (currentTool === 'pick') {
                const pickedColor = grid[y][x];
                if (pickedColor !== 'transparent') {
                    currentColor = pickedColor;
                    document.getElementById('currentColor').value = pickedColor;
                    document.querySelectorAll('.palette-color').forEach(el => {
                        el.classList.remove('active');
                        if (el.style.backgroundColor === pickedColor) {
                            el.classList.add('active');
                        }
                    });
                }
            }
        }

        function floodFill(x, y, targetColor, replacementColor) {
            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;
            if (grid[y][x] !== targetColor) return;
            if (targetColor === replacementColor) return;
            
            grid[y][x] = replacementColor;
            
            floodFill(x + 1, y, targetColor, replacementColor);
            floodFill(x - 1, y, targetColor, replacementColor);
            floodFill(x, y + 1, targetColor, replacementColor);
            floodFill(x, y - 1, targetColor, replacementColor);
        }

        function renderGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] !== 'transparent') {
                        ctx.fillStyle = grid[y][x];
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(120, 53, 15, 0.1)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * pixelSize, 0);
                ctx.lineTo(i * pixelSize, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * pixelSize);
                ctx.lineTo(canvas.width, i * pixelSize);
                ctx.stroke();
            }
        }

        function setGridSize(size) {
            gridSize = size;
            setupCanvas();
            clearCanvas();
            
            document.querySelectorAll('.grid-size-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(size + 'x' + size)) {
                    btn.classList.add('active');
                }
            });
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            if (tool === 'erase' || tool === 'draw') {
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'fill') {
                canvas.style.cursor = 'pointer';
            } else if (tool === 'pick') {
                canvas.style.cursor = 'cell';
            }
        }

        function clearCanvas() {
            grid = Array(gridSize).fill().map(() => 
                Array(gridSize).fill('transparent')
            );
            renderGrid();
        }

        function fillBackground() {
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    grid[y][x] = currentColor;
                }
            }
            renderGrid();
        }

        function generateRandomArt() {
            const patterns = [
                generateGradient,
                generateCheckerboard,
                generateCircle,
                generateDiamond,
                generateRandomNoise,
                generateSpiral,
                generateConcentric,
                generateStripes,
                generateCross
            ];
            
            patterns[currentPatternIndex]();
            currentPatternIndex = (currentPatternIndex + 1) % patterns.length;
            renderGrid();

        }



        function generateGradient() {
            const colors = ['#2563eb', '#1d4ed8', '#78350f', '#92400e', '#fef3c7', '#fde68a'];
            for (let y = 0; y < gridSize; y++) {
                const colorIndex = Math.floor((y / gridSize) * colors.length);
                for (let x = 0; x < gridSize; x++) {
                    grid[y][x] = colors[colorIndex];
                }
            }
        }



        function generateCheckerboard() {
            const colors = [currentColor, '#fef3c7'];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    grid[y][x] = colors[(x + y) % 2];
                }
            }
        }



        function generateCircle() {
            clearCanvas();
            const centerX = gridSize / 2;
            const centerY = gridSize / 2;
            const radius = gridSize / 3;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const distance = Math.sqrt(
                        Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
                    );
                    if (distance < radius) {
                        grid[y][x] = currentColor;
                    }
                }
            }
        }


        function generateDiamond() {
            clearCanvas();
            const centerX = gridSize / 2;
            const centerY = gridSize / 2;
            const size = gridSize / 3;
        
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (Math.abs(x - centerX) + Math.abs(y - centerY) < size) {
                        grid[y][x] = currentColor;
                    }
                }
            }
        }



        function generateRandomNoise() {
            const colors = ['#2563eb', '#1d4ed8', '#78350f', '#92400e', '#ef4444', '#f97316', '#22c55e', '#06b6d4'];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (Math.random() > 0.6) {
                        grid[y][x] = colors[Math.floor(Math.random() * colors.length)];
                    } else {
                        grid[y][x] = 'transparent';
                    }
                }
            }
        }


        function generateSpiral() {
            clearCanvas();
            const centerX = Math.floor(gridSize / 2);
            const centerY = Math.floor(gridSize / 2);
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const angle = Math.atan2(dy, dx);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const spiralValue = (angle + distance * 0.3) % (Math.PI * 2);

                    if (spiralValue < Math.PI) {
                        grid[y][x] = currentColor;
                    }
                }
            }
        }



        function generateConcentric() {
            clearCanvas();
            const centerX = gridSize / 2;
            const centerY = gridSize / 2;
            const colors = ['#2563eb', '#1d4ed8', '#78350f', '#92400e'];
     
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const distance = Math.sqrt(
                        Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
                    );
                    const ring = Math.floor(distance / 3) % colors.length;
                    grid[y][x] = colors[ring];
                }
            }
        }

        function generateStripes() {
            clearCanvas();
            const colors = [currentColor, '#fef3c7', '#1d4ed8'];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    grid[y][x] = colors[Math.floor(x / 4) % colors.length];
                }
            }
        }



        function generateCross() {
            clearCanvas();
            const centerX = Math.floor(gridSize / 2);
            const centerY = Math.floor(gridSize / 2);
            const thickness = Math.floor(gridSize / 8);

            

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (Math.abs(x - centerX) < thickness || Math.abs(y - centerY) < thickness) {
                        grid[y][x] = currentColor;
                    }
                }
            }
        }

        function downloadPixelArt() {
            const exportCanvas = document.createElement('canvas');
            const exportSize = 1024;
            const exportPixelSize = exportSize / gridSize;
            
            exportCanvas.width = exportSize;
            exportCanvas.height = exportSize;
            const exportCtx = exportCanvas.getContext('2d');
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] !== 'transparent') {
                        exportCtx.fillStyle = grid[y][x];
                        exportCtx.fillRect(
                            x * exportPixelSize, 
                            y * exportPixelSize, 
                            exportPixelSize, 
                            exportPixelSize
                        );
                    }
                }
            }
            
            const link = document.createElement('a');
            link.download = 'pixelate_art.png';
            link.href = exportCanvas.toDataURL();
            link.click();
        }

        function downloadPixelArtSmall() {
            const link = document.createElement('a');
            link.download = 'pixelate_art_small.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        // Initialize on load
        init();

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const oldGrid = grid.map(row => [...row]);
                setupCanvas();
                grid = oldGrid;
                renderGrid();
            }, 250);
        });
    </script>
</body>
</html>
